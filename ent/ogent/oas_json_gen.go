// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode implements json.Marshaler.
func (s CreateGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Admins != nil {
			e.Comma()
		}
		if s.Admins != nil {
			e.RawStr("\"admins\"" + ":")
			e.ArrStart()
			if len(s.Admins) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Admins[0]
					e.Int(elem)
				}
				for _, elem := range s.Admins[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					e.Int(elem)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Videos != nil {
			e.Comma()
		}
		if s.Videos != nil {
			e.RawStr("\"videos\"" + ":")
			e.ArrStart()
			if len(s.Videos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Videos[0]
					e.Int(elem)
				}
				for _, elem := range s.Videos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Moderators != nil {
			e.Comma()
		}
		if s.Moderators != nil {
			e.RawStr("\"moderators\"" + ":")
			e.ArrStart()
			if len(s.Moderators) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Moderators[0]
					e.Int(elem)
				}
				for _, elem := range s.Moderators[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Streamers != nil {
			e.Comma()
		}
		if s.Streamers != nil {
			e.RawStr("\"streamers\"" + ":")
			e.ArrStart()
			if len(s.Streamers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Streamers[0]
					e.Int(elem)
				}
				for _, elem := range s.Streamers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateGroupReq = [12]string{
	0:  "name",
	1:  "description",
	2:  "url",
	3:  "thumbnail",
	4:  "views",
	5:  "subscribers",
	6:  "created_at",
	7:  "admins",
	8:  "members",
	9:  "videos",
	10: "moderators",
	11: "streamers",
}

// Decode decodes CreateGroupReq from json.
func (s *CreateGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateGroupReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "admins":
			if err := func() error {
				s.Admins = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Admins = append(s.Admins, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admins\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "videos":
			if err := func() error {
				s.Videos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Videos = append(s.Videos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		case "moderators":
			if err := func() error {
				s.Moderators = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Moderators = append(s.Moderators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderators\"")
			}
		case "streamers":
			if err := func() error {
				s.Streamers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Streamers = append(s.Streamers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateGroupReq) {
					name = jsonFieldsNameOfCreateGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	{
		if s.JoinedGroups != nil {
			e.Comma()
		}
		if s.JoinedGroups != nil {
			e.RawStr("\"joined_groups\"" + ":")
			e.ArrStart()
			if len(s.JoinedGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.JoinedGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.JoinedGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeratingGroups != nil {
			e.Comma()
		}
		if s.ModeratingGroups != nil {
			e.RawStr("\"moderating_groups\"" + ":")
			e.ArrStart()
			if len(s.ModeratingGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ModeratingGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.ModeratingGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StreamingGroups != nil {
			e.Comma()
		}
		if s.StreamingGroups != nil {
			e.RawStr("\"streaming_groups\"" + ":")
			e.ArrStart()
			if len(s.StreamingGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StreamingGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.StreamingGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AdminGroups != nil {
			e.Comma()
		}
		if s.AdminGroups != nil {
			e.RawStr("\"admin_groups\"" + ":")
			e.ArrStart()
			if len(s.AdminGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AdminGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.AdminGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StreamVideos != nil {
			e.Comma()
		}
		if s.StreamVideos != nil {
			e.RawStr("\"stream_videos\"" + ":")
			e.ArrStart()
			if len(s.StreamVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StreamVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.StreamVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LikedVideos != nil {
			e.Comma()
		}
		if s.LikedVideos != nil {
			e.RawStr("\"liked_videos\"" + ":")
			e.ArrStart()
			if len(s.LikedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LikedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.LikedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ViewedVideos != nil {
			e.Comma()
		}
		if s.ViewedVideos != nil {
			e.RawStr("\"viewed_videos\"" + ":")
			e.ArrStart()
			if len(s.ViewedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ViewedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.ViewedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeratedVideos != nil {
			e.Comma()
		}
		if s.ModeratedVideos != nil {
			e.RawStr("\"moderated_videos\"" + ":")
			e.ArrStart()
			if len(s.ModeratedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ModeratedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.ModeratedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateUserReq = [11]string{
	0:  "name",
	1:  "uuid",
	2:  "password",
	3:  "joined_groups",
	4:  "moderating_groups",
	5:  "streaming_groups",
	6:  "admin_groups",
	7:  "stream_videos",
	8:  "liked_videos",
	9:  "viewed_videos",
	10: "moderated_videos",
}

// Decode decodes CreateUserReq from json.
func (s *CreateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "joined_groups":
			if err := func() error {
				s.JoinedGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.JoinedGroups = append(s.JoinedGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joined_groups\"")
			}
		case "moderating_groups":
			if err := func() error {
				s.ModeratingGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ModeratingGroups = append(s.ModeratingGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderating_groups\"")
			}
		case "streaming_groups":
			if err := func() error {
				s.StreamingGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.StreamingGroups = append(s.StreamingGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streaming_groups\"")
			}
		case "admin_groups":
			if err := func() error {
				s.AdminGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.AdminGroups = append(s.AdminGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin_groups\"")
			}
		case "stream_videos":
			if err := func() error {
				s.StreamVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.StreamVideos = append(s.StreamVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_videos\"")
			}
		case "liked_videos":
			if err := func() error {
				s.LikedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.LikedVideos = append(s.LikedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liked_videos\"")
			}
		case "viewed_videos":
			if err := func() error {
				s.ViewedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ViewedVideos = append(s.ViewedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewed_videos\"")
			}
		case "moderated_videos":
			if err := func() error {
				s.ModeratedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ModeratedVideos = append(s.ModeratedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderated_videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserReq) {
					name = jsonFieldsNameOfCreateUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateVideoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Group.Set {
			e.Comma()
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if s.Streamers != nil {
			e.Comma()
		}
		if s.Streamers != nil {
			e.RawStr("\"streamers\"" + ":")
			e.ArrStart()
			if len(s.Streamers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Streamers[0]
					e.Int(elem)
				}
				for _, elem := range s.Streamers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Moderaters != nil {
			e.Comma()
		}
		if s.Moderaters != nil {
			e.RawStr("\"moderaters\"" + ":")
			e.ArrStart()
			if len(s.Moderaters) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Moderaters[0]
					e.Int(elem)
				}
				for _, elem := range s.Moderaters[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Likes != nil {
			e.Comma()
		}
		if s.Likes != nil {
			e.RawStr("\"likes\"" + ":")
			e.ArrStart()
			if len(s.Likes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Likes[0]
					e.Int(elem)
				}
				for _, elem := range s.Likes[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Viewers != nil {
			e.Comma()
		}
		if s.Viewers != nil {
			e.RawStr("\"viewers\"" + ":")
			e.ArrStart()
			if len(s.Viewers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Viewers[0]
					e.Int(elem)
				}
				for _, elem := range s.Viewers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateVideoReq = [10]string{
	0: "uuid",
	1: "title",
	2: "description",
	3: "videotype",
	4: "created_at",
	5: "group",
	6: "streamers",
	7: "moderaters",
	8: "likes",
	9: "viewers",
}

// Decode decodes CreateVideoReq from json.
func (s *CreateVideoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVideoReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "streamers":
			if err := func() error {
				s.Streamers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Streamers = append(s.Streamers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamers\"")
			}
		case "moderaters":
			if err := func() error {
				s.Moderaters = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Moderaters = append(s.Moderaters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderaters\"")
			}
		case "likes":
			if err := func() error {
				s.Likes = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Likes = append(s.Likes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"likes\"")
			}
		case "viewers":
			if err := func() error {
				s.Viewers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Viewers = append(s.Viewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVideoReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVideoReq) {
					name = jsonFieldsNameOfCreateVideoReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CreateVideoReqVideotype as json.
func (s CreateVideoReqVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CreateVideoReqVideotype from json.
func (s *CreateVideoReqVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVideoReqVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateVideoReqVideotype(v) {
	case CreateVideoReqVideotypeLive:
		*s = CreateVideoReqVideotypeLive
	case CreateVideoReqVideotypeVideo:
		*s = CreateVideoReqVideotypeVideo
	case CreateVideoReqVideotypePlaylist:
		*s = CreateVideoReqVideotypePlaylist
	default:
		*s = CreateVideoReqVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupAdminsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupAdminsList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes GroupAdminsList from json.
func (s *GroupAdminsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupAdminsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupAdminsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupAdminsList) {
					name = jsonFieldsNameOfGroupAdminsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupCreate = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes GroupCreate from json.
func (s *GroupCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupCreate) {
					name = jsonFieldsNameOfGroupCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupList = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes GroupList from json.
func (s *GroupList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupList) {
					name = jsonFieldsNameOfGroupList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupMembersList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupMembersList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes GroupMembersList from json.
func (s *GroupMembersList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupMembersList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupMembersList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupMembersList) {
					name = jsonFieldsNameOfGroupMembersList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupModeratorsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupModeratorsList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes GroupModeratorsList from json.
func (s *GroupModeratorsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupModeratorsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupModeratorsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupModeratorsList) {
					name = jsonFieldsNameOfGroupModeratorsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupRead = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes GroupRead from json.
func (s *GroupRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupRead) {
					name = jsonFieldsNameOfGroupRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupStreamersList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupStreamersList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes GroupStreamersList from json.
func (s *GroupStreamersList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupStreamersList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupStreamersList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupStreamersList) {
					name = jsonFieldsNameOfGroupStreamersList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupUpdate = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes GroupUpdate from json.
func (s *GroupUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupUpdate) {
					name = jsonFieldsNameOfGroupUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupVideosList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupVideosList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes GroupVideosList from json.
func (s *GroupVideosList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupVideosList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupVideosList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupVideosList) {
					name = jsonFieldsNameOfGroupVideosList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes GroupVideosListVideotype as json.
func (s GroupVideosListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GroupVideosListVideotype from json.
func (s *GroupVideosListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupVideosListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GroupVideosListVideotype(v) {
	case GroupVideosListVideotypeLive:
		*s = GroupVideosListVideotypeLive
	case GroupVideosListVideotypeVideo:
		*s = GroupVideosListVideotypeVideo
	case GroupVideosListVideotypePlaylist:
		*s = GroupVideosListVideotypePlaylist
	default:
		*s = GroupVideosListVideotype(v)
	}

	return nil
}

// Encode encodes ListGroupAdminsOKApplicationJSON as json.
func (s ListGroupAdminsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupAdminsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupAdminsOKApplicationJSON from json.
func (s *ListGroupAdminsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupAdminsOKApplicationJSON to nil")
	}
	var unwrapped []GroupAdminsList
	if err := func() error {
		unwrapped = make([]GroupAdminsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupAdminsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupAdminsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListGroupMembersOKApplicationJSON as json.
func (s ListGroupMembersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupMembersList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupMembersOKApplicationJSON from json.
func (s *ListGroupMembersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupMembersOKApplicationJSON to nil")
	}
	var unwrapped []GroupMembersList
	if err := func() error {
		unwrapped = make([]GroupMembersList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupMembersList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupMembersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListGroupModeratorsOKApplicationJSON as json.
func (s ListGroupModeratorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupModeratorsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupModeratorsOKApplicationJSON from json.
func (s *ListGroupModeratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupModeratorsOKApplicationJSON to nil")
	}
	var unwrapped []GroupModeratorsList
	if err := func() error {
		unwrapped = make([]GroupModeratorsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupModeratorsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupModeratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListGroupOKApplicationJSON as json.
func (s ListGroupOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupOKApplicationJSON from json.
func (s *ListGroupOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupOKApplicationJSON to nil")
	}
	var unwrapped []GroupList
	if err := func() error {
		unwrapped = make([]GroupList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListGroupStreamersOKApplicationJSON as json.
func (s ListGroupStreamersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupStreamersList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupStreamersOKApplicationJSON from json.
func (s *ListGroupStreamersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupStreamersOKApplicationJSON to nil")
	}
	var unwrapped []GroupStreamersList
	if err := func() error {
		unwrapped = make([]GroupStreamersList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupStreamersList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupStreamersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListGroupVideosOKApplicationJSON as json.
func (s ListGroupVideosOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GroupVideosList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListGroupVideosOKApplicationJSON from json.
func (s *ListGroupVideosOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGroupVideosOKApplicationJSON to nil")
	}
	var unwrapped []GroupVideosList
	if err := func() error {
		unwrapped = make([]GroupVideosList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GroupVideosList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGroupVideosOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserAdminGroupsOKApplicationJSON as json.
func (s ListUserAdminGroupsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserAdminGroupsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserAdminGroupsOKApplicationJSON from json.
func (s *ListUserAdminGroupsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserAdminGroupsOKApplicationJSON to nil")
	}
	var unwrapped []UserAdminGroupsList
	if err := func() error {
		unwrapped = make([]UserAdminGroupsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserAdminGroupsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserAdminGroupsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserJoinedGroupsOKApplicationJSON as json.
func (s ListUserJoinedGroupsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserJoinedGroupsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserJoinedGroupsOKApplicationJSON from json.
func (s *ListUserJoinedGroupsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserJoinedGroupsOKApplicationJSON to nil")
	}
	var unwrapped []UserJoinedGroupsList
	if err := func() error {
		unwrapped = make([]UserJoinedGroupsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserJoinedGroupsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserJoinedGroupsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserLikedVideosOKApplicationJSON as json.
func (s ListUserLikedVideosOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserLikedVideosList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserLikedVideosOKApplicationJSON from json.
func (s *ListUserLikedVideosOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserLikedVideosOKApplicationJSON to nil")
	}
	var unwrapped []UserLikedVideosList
	if err := func() error {
		unwrapped = make([]UserLikedVideosList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserLikedVideosList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserLikedVideosOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserModeratedVideosOKApplicationJSON as json.
func (s ListUserModeratedVideosOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserModeratedVideosList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserModeratedVideosOKApplicationJSON from json.
func (s *ListUserModeratedVideosOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserModeratedVideosOKApplicationJSON to nil")
	}
	var unwrapped []UserModeratedVideosList
	if err := func() error {
		unwrapped = make([]UserModeratedVideosList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserModeratedVideosList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserModeratedVideosOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserModeratingGroupsOKApplicationJSON as json.
func (s ListUserModeratingGroupsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserModeratingGroupsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserModeratingGroupsOKApplicationJSON from json.
func (s *ListUserModeratingGroupsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserModeratingGroupsOKApplicationJSON to nil")
	}
	var unwrapped []UserModeratingGroupsList
	if err := func() error {
		unwrapped = make([]UserModeratingGroupsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserModeratingGroupsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserModeratingGroupsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserOKApplicationJSON as json.
func (s ListUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserOKApplicationJSON from json.
func (s *ListUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserOKApplicationJSON to nil")
	}
	var unwrapped []UserList
	if err := func() error {
		unwrapped = make([]UserList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserStreamVideosOKApplicationJSON as json.
func (s ListUserStreamVideosOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserStreamVideosList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserStreamVideosOKApplicationJSON from json.
func (s *ListUserStreamVideosOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserStreamVideosOKApplicationJSON to nil")
	}
	var unwrapped []UserStreamVideosList
	if err := func() error {
		unwrapped = make([]UserStreamVideosList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserStreamVideosList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserStreamVideosOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserStreamingGroupsOKApplicationJSON as json.
func (s ListUserStreamingGroupsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserStreamingGroupsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserStreamingGroupsOKApplicationJSON from json.
func (s *ListUserStreamingGroupsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserStreamingGroupsOKApplicationJSON to nil")
	}
	var unwrapped []UserStreamingGroupsList
	if err := func() error {
		unwrapped = make([]UserStreamingGroupsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserStreamingGroupsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserStreamingGroupsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserViewedVideosOKApplicationJSON as json.
func (s ListUserViewedVideosOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserViewedVideosList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserViewedVideosOKApplicationJSON from json.
func (s *ListUserViewedVideosOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserViewedVideosOKApplicationJSON to nil")
	}
	var unwrapped []UserViewedVideosList
	if err := func() error {
		unwrapped = make([]UserViewedVideosList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserViewedVideosList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserViewedVideosOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListVideoLikesOKApplicationJSON as json.
func (s ListVideoLikesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []VideoLikesList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListVideoLikesOKApplicationJSON from json.
func (s *ListVideoLikesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVideoLikesOKApplicationJSON to nil")
	}
	var unwrapped []VideoLikesList
	if err := func() error {
		unwrapped = make([]VideoLikesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VideoLikesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVideoLikesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListVideoModeratersOKApplicationJSON as json.
func (s ListVideoModeratersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []VideoModeratersList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListVideoModeratersOKApplicationJSON from json.
func (s *ListVideoModeratersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVideoModeratersOKApplicationJSON to nil")
	}
	var unwrapped []VideoModeratersList
	if err := func() error {
		unwrapped = make([]VideoModeratersList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VideoModeratersList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVideoModeratersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListVideoOKApplicationJSON as json.
func (s ListVideoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []VideoList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListVideoOKApplicationJSON from json.
func (s *ListVideoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVideoOKApplicationJSON to nil")
	}
	var unwrapped []VideoList
	if err := func() error {
		unwrapped = make([]VideoList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VideoList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVideoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListVideoStreamersOKApplicationJSON as json.
func (s ListVideoStreamersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []VideoStreamersList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListVideoStreamersOKApplicationJSON from json.
func (s *ListVideoStreamersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVideoStreamersOKApplicationJSON to nil")
	}
	var unwrapped []VideoStreamersList
	if err := func() error {
		unwrapped = make([]VideoStreamersList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VideoStreamersList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVideoStreamersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListVideoViewersOKApplicationJSON as json.
func (s ListVideoViewersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []VideoViewersList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListVideoViewersOKApplicationJSON from json.
func (s *ListVideoViewersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVideoViewersOKApplicationJSON to nil")
	}
	var unwrapped []VideoViewersList
	if err := func() error {
		unwrapped = make([]VideoViewersList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VideoViewersList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVideoViewersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// Encode encodes UpdateVideoReqVideotype as json.
func (o OptUpdateVideoReqVideotype) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateVideoReqVideotype from json.
func (o *OptUpdateVideoReqVideotype) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateVideoReqVideotype to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode implements json.Marshaler.
func (s R400) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R404) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R409) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R500) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdateGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Thumbnail.Set {
			e.RawStr("\"thumbnail\"" + ":")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Views.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Views.Set {
			e.RawStr("\"views\"" + ":")
			s.Views.Encode(e)
		}
	}
	{
		if s.Subscribers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subscribers.Set {
			e.RawStr("\"subscribers\"" + ":")
			s.Subscribers.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Admins != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admins != nil {
			e.RawStr("\"admins\"" + ":")
			e.ArrStart()
			if len(s.Admins) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Admins[0]
					e.Int(elem)
				}
				for _, elem := range s.Admins[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Members != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					e.Int(elem)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Videos != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Videos != nil {
			e.RawStr("\"videos\"" + ":")
			e.ArrStart()
			if len(s.Videos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Videos[0]
					e.Int(elem)
				}
				for _, elem := range s.Videos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Moderators != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Moderators != nil {
			e.RawStr("\"moderators\"" + ":")
			e.ArrStart()
			if len(s.Moderators) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Moderators[0]
					e.Int(elem)
				}
				for _, elem := range s.Moderators[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Streamers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Streamers != nil {
			e.RawStr("\"streamers\"" + ":")
			e.ArrStart()
			if len(s.Streamers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Streamers[0]
					e.Int(elem)
				}
				for _, elem := range s.Streamers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdateGroupReq = [12]string{
	0:  "name",
	1:  "description",
	2:  "url",
	3:  "thumbnail",
	4:  "views",
	5:  "subscribers",
	6:  "created_at",
	7:  "admins",
	8:  "members",
	9:  "videos",
	10: "moderators",
	11: "streamers",
}

// Decode decodes UpdateGroupReq from json.
func (s *UpdateGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			if err := func() error {
				s.Views.Reset()
				if err := s.Views.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			if err := func() error {
				s.Subscribers.Reset()
				if err := s.Subscribers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "admins":
			if err := func() error {
				s.Admins = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Admins = append(s.Admins, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admins\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "videos":
			if err := func() error {
				s.Videos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Videos = append(s.Videos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		case "moderators":
			if err := func() error {
				s.Moderators = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Moderators = append(s.Moderators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderators\"")
			}
		case "streamers":
			if err := func() error {
				s.Streamers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Streamers = append(s.Streamers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateGroupReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdateUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UUID.Set {
			e.RawStr("\"uuid\"" + ":")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Password.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Password.Set {
			e.RawStr("\"password\"" + ":")
			s.Password.Encode(e)
		}
	}
	{
		if s.JoinedGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.JoinedGroups != nil {
			e.RawStr("\"joined_groups\"" + ":")
			e.ArrStart()
			if len(s.JoinedGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.JoinedGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.JoinedGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeratingGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ModeratingGroups != nil {
			e.RawStr("\"moderating_groups\"" + ":")
			e.ArrStart()
			if len(s.ModeratingGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ModeratingGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.ModeratingGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StreamingGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StreamingGroups != nil {
			e.RawStr("\"streaming_groups\"" + ":")
			e.ArrStart()
			if len(s.StreamingGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StreamingGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.StreamingGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AdminGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdminGroups != nil {
			e.RawStr("\"admin_groups\"" + ":")
			e.ArrStart()
			if len(s.AdminGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AdminGroups[0]
					e.Int(elem)
				}
				for _, elem := range s.AdminGroups[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StreamVideos != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StreamVideos != nil {
			e.RawStr("\"stream_videos\"" + ":")
			e.ArrStart()
			if len(s.StreamVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StreamVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.StreamVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LikedVideos != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LikedVideos != nil {
			e.RawStr("\"liked_videos\"" + ":")
			e.ArrStart()
			if len(s.LikedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LikedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.LikedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ViewedVideos != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ViewedVideos != nil {
			e.RawStr("\"viewed_videos\"" + ":")
			e.ArrStart()
			if len(s.ViewedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ViewedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.ViewedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeratedVideos != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ModeratedVideos != nil {
			e.RawStr("\"moderated_videos\"" + ":")
			e.ArrStart()
			if len(s.ModeratedVideos) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ModeratedVideos[0]
					e.Int(elem)
				}
				for _, elem := range s.ModeratedVideos[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdateUserReq = [11]string{
	0:  "name",
	1:  "uuid",
	2:  "password",
	3:  "joined_groups",
	4:  "moderating_groups",
	5:  "streaming_groups",
	6:  "admin_groups",
	7:  "stream_videos",
	8:  "liked_videos",
	9:  "viewed_videos",
	10: "moderated_videos",
}

// Decode decodes UpdateUserReq from json.
func (s *UpdateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "joined_groups":
			if err := func() error {
				s.JoinedGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.JoinedGroups = append(s.JoinedGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joined_groups\"")
			}
		case "moderating_groups":
			if err := func() error {
				s.ModeratingGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ModeratingGroups = append(s.ModeratingGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderating_groups\"")
			}
		case "streaming_groups":
			if err := func() error {
				s.StreamingGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.StreamingGroups = append(s.StreamingGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streaming_groups\"")
			}
		case "admin_groups":
			if err := func() error {
				s.AdminGroups = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.AdminGroups = append(s.AdminGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin_groups\"")
			}
		case "stream_videos":
			if err := func() error {
				s.StreamVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.StreamVideos = append(s.StreamVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_videos\"")
			}
		case "liked_videos":
			if err := func() error {
				s.LikedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.LikedVideos = append(s.LikedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liked_videos\"")
			}
		case "viewed_videos":
			if err := func() error {
				s.ViewedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ViewedVideos = append(s.ViewedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewed_videos\"")
			}
		case "moderated_videos":
			if err := func() error {
				s.ModeratedVideos = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.ModeratedVideos = append(s.ModeratedVideos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderated_videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdateVideoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.UUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UUID.Set {
			e.RawStr("\"uuid\"" + ":")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Videotype.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Videotype.Set {
			e.RawStr("\"videotype\"" + ":")
			s.Videotype.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if s.Streamers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Streamers != nil {
			e.RawStr("\"streamers\"" + ":")
			e.ArrStart()
			if len(s.Streamers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Streamers[0]
					e.Int(elem)
				}
				for _, elem := range s.Streamers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Moderaters != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Moderaters != nil {
			e.RawStr("\"moderaters\"" + ":")
			e.ArrStart()
			if len(s.Moderaters) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Moderaters[0]
					e.Int(elem)
				}
				for _, elem := range s.Moderaters[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Likes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Likes != nil {
			e.RawStr("\"likes\"" + ":")
			e.ArrStart()
			if len(s.Likes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Likes[0]
					e.Int(elem)
				}
				for _, elem := range s.Likes[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Viewers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Viewers != nil {
			e.RawStr("\"viewers\"" + ":")
			e.ArrStart()
			if len(s.Viewers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Viewers[0]
					e.Int(elem)
				}
				for _, elem := range s.Viewers[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdateVideoReq = [10]string{
	0: "uuid",
	1: "title",
	2: "description",
	3: "videotype",
	4: "created_at",
	5: "group",
	6: "streamers",
	7: "moderaters",
	8: "likes",
	9: "viewers",
}

// Decode decodes UpdateVideoReq from json.
func (s *UpdateVideoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVideoReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			if err := func() error {
				s.Videotype.Reset()
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "streamers":
			if err := func() error {
				s.Streamers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Streamers = append(s.Streamers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamers\"")
			}
		case "moderaters":
			if err := func() error {
				s.Moderaters = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Moderaters = append(s.Moderaters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderaters\"")
			}
		case "likes":
			if err := func() error {
				s.Likes = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Likes = append(s.Likes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"likes\"")
			}
		case "viewers":
			if err := func() error {
				s.Viewers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Viewers = append(s.Viewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVideoReq")
	}

	return nil
}

// Encode encodes UpdateVideoReqVideotype as json.
func (s UpdateVideoReqVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UpdateVideoReqVideotype from json.
func (s *UpdateVideoReqVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVideoReqVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateVideoReqVideotype(v) {
	case UpdateVideoReqVideotypeLive:
		*s = UpdateVideoReqVideotypeLive
	case UpdateVideoReqVideotypeVideo:
		*s = UpdateVideoReqVideotypeVideo
	case UpdateVideoReqVideotypePlaylist:
		*s = UpdateVideoReqVideotypePlaylist
	default:
		*s = UpdateVideoReqVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserAdminGroupsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserAdminGroupsList = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes UserAdminGroupsList from json.
func (s *UserAdminGroupsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdminGroupsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdminGroupsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAdminGroupsList) {
					name = jsonFieldsNameOfUserAdminGroupsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserCreate = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes UserCreate from json.
func (s *UserCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserCreate) {
					name = jsonFieldsNameOfUserCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserJoinedGroupsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserJoinedGroupsList = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes UserJoinedGroupsList from json.
func (s *UserJoinedGroupsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserJoinedGroupsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserJoinedGroupsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserJoinedGroupsList) {
					name = jsonFieldsNameOfUserJoinedGroupsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserLikedVideosList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserLikedVideosList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes UserLikedVideosList from json.
func (s *UserLikedVideosList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserLikedVideosList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserLikedVideosList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserLikedVideosList) {
					name = jsonFieldsNameOfUserLikedVideosList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserLikedVideosListVideotype as json.
func (s UserLikedVideosListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserLikedVideosListVideotype from json.
func (s *UserLikedVideosListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserLikedVideosListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserLikedVideosListVideotype(v) {
	case UserLikedVideosListVideotypeLive:
		*s = UserLikedVideosListVideotypeLive
	case UserLikedVideosListVideotypeVideo:
		*s = UserLikedVideosListVideotypeVideo
	case UserLikedVideosListVideotypePlaylist:
		*s = UserLikedVideosListVideotypePlaylist
	default:
		*s = UserLikedVideosListVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes UserList from json.
func (s *UserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserList) {
					name = jsonFieldsNameOfUserList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserModeratedVideosList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserModeratedVideosList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes UserModeratedVideosList from json.
func (s *UserModeratedVideosList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModeratedVideosList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserModeratedVideosList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserModeratedVideosList) {
					name = jsonFieldsNameOfUserModeratedVideosList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserModeratedVideosListVideotype as json.
func (s UserModeratedVideosListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserModeratedVideosListVideotype from json.
func (s *UserModeratedVideosListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModeratedVideosListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserModeratedVideosListVideotype(v) {
	case UserModeratedVideosListVideotypeLive:
		*s = UserModeratedVideosListVideotypeLive
	case UserModeratedVideosListVideotypeVideo:
		*s = UserModeratedVideosListVideotypeVideo
	case UserModeratedVideosListVideotypePlaylist:
		*s = UserModeratedVideosListVideotypePlaylist
	default:
		*s = UserModeratedVideosListVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserModeratingGroupsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserModeratingGroupsList = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes UserModeratingGroupsList from json.
func (s *UserModeratingGroupsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModeratingGroupsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserModeratingGroupsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserModeratingGroupsList) {
					name = jsonFieldsNameOfUserModeratingGroupsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserRead = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes UserRead from json.
func (s *UserRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserRead) {
					name = jsonFieldsNameOfUserRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserStreamVideosList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserStreamVideosList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes UserStreamVideosList from json.
func (s *UserStreamVideosList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStreamVideosList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserStreamVideosList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserStreamVideosList) {
					name = jsonFieldsNameOfUserStreamVideosList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserStreamVideosListVideotype as json.
func (s UserStreamVideosListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserStreamVideosListVideotype from json.
func (s *UserStreamVideosListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStreamVideosListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserStreamVideosListVideotype(v) {
	case UserStreamVideosListVideotypeLive:
		*s = UserStreamVideosListVideotypeLive
	case UserStreamVideosListVideotypeVideo:
		*s = UserStreamVideosListVideotypeVideo
	case UserStreamVideosListVideotypePlaylist:
		*s = UserStreamVideosListVideotypePlaylist
	default:
		*s = UserStreamVideosListVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserStreamingGroupsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserStreamingGroupsList = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes UserStreamingGroupsList from json.
func (s *UserStreamingGroupsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStreamingGroupsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserStreamingGroupsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserStreamingGroupsList) {
					name = jsonFieldsNameOfUserStreamingGroupsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserUpdate = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes UserUpdate from json.
func (s *UserUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUpdate) {
					name = jsonFieldsNameOfUserUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserViewedVideosList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserViewedVideosList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes UserViewedVideosList from json.
func (s *UserViewedVideosList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserViewedVideosList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserViewedVideosList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserViewedVideosList) {
					name = jsonFieldsNameOfUserViewedVideosList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserViewedVideosListVideotype as json.
func (s UserViewedVideosListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserViewedVideosListVideotype from json.
func (s *UserViewedVideosListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserViewedVideosListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserViewedVideosListVideotype(v) {
	case UserViewedVideosListVideotypeLive:
		*s = UserViewedVideosListVideotypeLive
	case UserViewedVideosListVideotypeVideo:
		*s = UserViewedVideosListVideotypeVideo
	case UserViewedVideosListVideotypePlaylist:
		*s = UserViewedVideosListVideotypePlaylist
	default:
		*s = UserViewedVideosListVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoCreate = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes VideoCreate from json.
func (s *VideoCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoCreate) {
					name = jsonFieldsNameOfVideoCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes VideoCreateVideotype as json.
func (s VideoCreateVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes VideoCreateVideotype from json.
func (s *VideoCreateVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoCreateVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoCreateVideotype(v) {
	case VideoCreateVideotypeLive:
		*s = VideoCreateVideotypeLive
	case VideoCreateVideotypeVideo:
		*s = VideoCreateVideotypeVideo
	case VideoCreateVideotypePlaylist:
		*s = VideoCreateVideotypePlaylist
	default:
		*s = VideoCreateVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoGroupRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"thumbnail\"" + ":")
		e.Str(s.Thumbnail)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.Int(s.Views)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers\"" + ":")
		e.Int(s.Subscribers)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoGroupRead = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "url",
	4: "thumbnail",
	5: "views",
	6: "subscribers",
	7: "created_at",
}

// Decode decodes VideoGroupRead from json.
func (s *VideoGroupRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoGroupRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		case "subscribers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Subscribers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoGroupRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoGroupRead) {
					name = jsonFieldsNameOfVideoGroupRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoLikesList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoLikesList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes VideoLikesList from json.
func (s *VideoLikesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoLikesList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoLikesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoLikesList) {
					name = jsonFieldsNameOfVideoLikesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoList = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes VideoList from json.
func (s *VideoList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoList) {
					name = jsonFieldsNameOfVideoList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes VideoListVideotype as json.
func (s VideoListVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes VideoListVideotype from json.
func (s *VideoListVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoListVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoListVideotype(v) {
	case VideoListVideotypeLive:
		*s = VideoListVideotypeLive
	case VideoListVideotypeVideo:
		*s = VideoListVideotypeVideo
	case VideoListVideotypePlaylist:
		*s = VideoListVideotypePlaylist
	default:
		*s = VideoListVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoModeratersList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoModeratersList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes VideoModeratersList from json.
func (s *VideoModeratersList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoModeratersList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoModeratersList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoModeratersList) {
					name = jsonFieldsNameOfVideoModeratersList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoRead = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes VideoRead from json.
func (s *VideoRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoRead) {
					name = jsonFieldsNameOfVideoRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes VideoReadVideotype as json.
func (s VideoReadVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes VideoReadVideotype from json.
func (s *VideoReadVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoReadVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoReadVideotype(v) {
	case VideoReadVideotypeLive:
		*s = VideoReadVideotypeLive
	case VideoReadVideotypeVideo:
		*s = VideoReadVideotypeVideo
	case VideoReadVideotypePlaylist:
		*s = VideoReadVideotypePlaylist
	default:
		*s = VideoReadVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoStreamersList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoStreamersList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes VideoStreamersList from json.
func (s *VideoStreamersList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoStreamersList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoStreamersList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoStreamersList) {
					name = jsonFieldsNameOfVideoStreamersList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"videotype\"" + ":")
		s.Videotype.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoUpdate = [6]string{
	0: "id",
	1: "uuid",
	2: "title",
	3: "description",
	4: "videotype",
	5: "created_at",
}

// Decode decodes VideoUpdate from json.
func (s *VideoUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "videotype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Videotype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videotype\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoUpdate) {
					name = jsonFieldsNameOfVideoUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes VideoUpdateVideotype as json.
func (s VideoUpdateVideotype) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes VideoUpdateVideotype from json.
func (s *VideoUpdateVideotype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoUpdateVideotype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoUpdateVideotype(v) {
	case VideoUpdateVideotypeLive:
		*s = VideoUpdateVideotypeLive
	case VideoUpdateVideotypeVideo:
		*s = VideoUpdateVideotypeVideo
	case VideoUpdateVideotypePlaylist:
		*s = VideoUpdateVideotypePlaylist
	default:
		*s = VideoUpdateVideotype(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoViewersList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uuid\"" + ":")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.Comma()

		e.RawStr("\"password\"" + ":")
		e.Str(s.Password)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoViewersList = [4]string{
	0: "id",
	1: "name",
	2: "uuid",
	3: "password",
}

// Decode decodes VideoViewersList from json.
func (s *VideoViewersList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoViewersList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoViewersList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoViewersList) {
					name = jsonFieldsNameOfVideoViewersList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}
