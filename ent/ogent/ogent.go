// Code generated by entc, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"example.com/enumeg/ent"
	"example.com/enumeg/ent/group"
	"example.com/enumeg/ent/user"
	"example.com/enumeg/ent/video"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateGroup handles POST /groups requests.
func (h *OgentHandler) CreateGroup(ctx context.Context, req CreateGroupReq) (CreateGroupRes, error) {
	b := h.client.Group.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDescription(req.Description)
	b.SetURL(req.URL)
	b.SetThumbnail(req.Thumbnail)
	b.SetViews(req.Views)
	b.SetSubscribers(req.Subscribers)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	b.AddAdminIDs(req.Admins...)
	b.AddMemberIDs(req.Members...)
	b.AddVideoIDs(req.Videos...)
	b.AddModeratorIDs(req.Moderators...)
	b.AddStreamerIDs(req.Streamers...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupCreate(e), nil
}

// ReadGroup handles GET /groups/{id} requests.
func (h *OgentHandler) ReadGroup(ctx context.Context, params ReadGroupParams) (ReadGroupRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupRead(e), nil
}

// UpdateGroup handles PATCH /groups/{id} requests.
func (h *OgentHandler) UpdateGroup(ctx context.Context, req UpdateGroupReq, params UpdateGroupParams) (UpdateGroupRes, error) {
	b := h.client.Group.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.URL.Get(); ok {
		b.SetURL(v)
	}
	if v, ok := req.Thumbnail.Get(); ok {
		b.SetThumbnail(v)
	}
	if v, ok := req.Views.Get(); ok {
		b.SetViews(v)
	}
	if v, ok := req.Subscribers.Get(); ok {
		b.SetSubscribers(v)
	}
	if v, ok := req.CreatedAt.Get(); ok {
		b.SetCreatedAt(v)
	}
	// Add all edges.
	b.ClearAdmins().AddAdminIDs(req.Admins...)
	b.ClearMembers().AddMemberIDs(req.Members...)
	b.ClearVideos().AddVideoIDs(req.Videos...)
	b.ClearModerators().AddModeratorIDs(req.Moderators...)
	b.ClearStreamers().AddStreamerIDs(req.Streamers...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupUpdate(e), nil
}

// DeleteGroup handles DELETE /groups/{id} requests.
func (h *OgentHandler) DeleteGroup(ctx context.Context, params DeleteGroupParams) (DeleteGroupRes, error) {
	err := h.client.Group.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGroupNoContent), nil

}

// ListGroup handles GET /groups requests.
func (h *OgentHandler) ListGroup(ctx context.Context, params ListGroupParams) (ListGroupRes, error) {
	q := h.client.Group.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupOKApplicationJSON(NewGroupLists(es)), nil
}

// ListGroupAdmins handles GET /groups/{id}/admins requests.
func (h *OgentHandler) ListGroupAdmins(ctx context.Context, params ListGroupAdminsParams) (ListGroupAdminsRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryAdmins()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupAdminsOKApplicationJSON(NewGroupAdminsLists(es)), nil
}

// ListGroupMembers handles GET /groups/{id}/members requests.
func (h *OgentHandler) ListGroupMembers(ctx context.Context, params ListGroupMembersParams) (ListGroupMembersRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryMembers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupMembersOKApplicationJSON(NewGroupMembersLists(es)), nil
}

// ListGroupVideos handles GET /groups/{id}/videos requests.
func (h *OgentHandler) ListGroupVideos(ctx context.Context, params ListGroupVideosParams) (ListGroupVideosRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryVideos()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupVideosOKApplicationJSON(NewGroupVideosLists(es)), nil
}

// ListGroupModerators handles GET /groups/{id}/moderators requests.
func (h *OgentHandler) ListGroupModerators(ctx context.Context, params ListGroupModeratorsParams) (ListGroupModeratorsRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryModerators()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupModeratorsOKApplicationJSON(NewGroupModeratorsLists(es)), nil
}

// ListGroupStreamers handles GET /groups/{id}/streamers requests.
func (h *OgentHandler) ListGroupStreamers(ctx context.Context, params ListGroupStreamersParams) (ListGroupStreamersRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryStreamers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListGroupStreamersOKApplicationJSON(NewGroupStreamersLists(es)), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetUUID(req.UUID)
	b.SetPassword(req.Password)
	// Add all edges.
	b.AddJoinedGroupIDs(req.JoinedGroups...)
	b.AddModeratingGroupIDs(req.ModeratingGroups...)
	b.AddStreamingGroupIDs(req.StreamingGroups...)
	b.AddAdminGroupIDs(req.AdminGroups...)
	b.AddStreamVideoIDs(req.StreamVideos...)
	b.AddLikedVideoIDs(req.LikedVideos...)
	b.AddViewedVideoIDs(req.ViewedVideos...)
	b.AddModeratedVideoIDs(req.ModeratedVideos...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.UUID.Get(); ok {
		b.SetUUID(v)
	}
	if v, ok := req.Password.Get(); ok {
		b.SetPassword(v)
	}
	// Add all edges.
	b.ClearJoinedGroups().AddJoinedGroupIDs(req.JoinedGroups...)
	b.ClearModeratingGroups().AddModeratingGroupIDs(req.ModeratingGroups...)
	b.ClearStreamingGroups().AddStreamingGroupIDs(req.StreamingGroups...)
	b.ClearAdminGroups().AddAdminGroupIDs(req.AdminGroups...)
	b.ClearStreamVideos().AddStreamVideoIDs(req.StreamVideos...)
	b.ClearLikedVideos().AddLikedVideoIDs(req.LikedVideos...)
	b.ClearViewedVideos().AddViewedVideoIDs(req.ViewedVideos...)
	b.ClearModeratedVideos().AddModeratedVideoIDs(req.ModeratedVideos...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserOKApplicationJSON(NewUserLists(es)), nil
}

// ListUserJoinedGroups handles GET /users/{id}/joined-groups requests.
func (h *OgentHandler) ListUserJoinedGroups(ctx context.Context, params ListUserJoinedGroupsParams) (ListUserJoinedGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryJoinedGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserJoinedGroupsOKApplicationJSON(NewUserJoinedGroupsLists(es)), nil
}

// ListUserModeratingGroups handles GET /users/{id}/moderating-groups requests.
func (h *OgentHandler) ListUserModeratingGroups(ctx context.Context, params ListUserModeratingGroupsParams) (ListUserModeratingGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryModeratingGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserModeratingGroupsOKApplicationJSON(NewUserModeratingGroupsLists(es)), nil
}

// ListUserStreamingGroups handles GET /users/{id}/streaming-groups requests.
func (h *OgentHandler) ListUserStreamingGroups(ctx context.Context, params ListUserStreamingGroupsParams) (ListUserStreamingGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryStreamingGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserStreamingGroupsOKApplicationJSON(NewUserStreamingGroupsLists(es)), nil
}

// ListUserAdminGroups handles GET /users/{id}/admin-groups requests.
func (h *OgentHandler) ListUserAdminGroups(ctx context.Context, params ListUserAdminGroupsParams) (ListUserAdminGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryAdminGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserAdminGroupsOKApplicationJSON(NewUserAdminGroupsLists(es)), nil
}

// ListUserStreamVideos handles GET /users/{id}/stream-videos requests.
func (h *OgentHandler) ListUserStreamVideos(ctx context.Context, params ListUserStreamVideosParams) (ListUserStreamVideosRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryStreamVideos()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserStreamVideosOKApplicationJSON(NewUserStreamVideosLists(es)), nil
}

// ListUserLikedVideos handles GET /users/{id}/liked-videos requests.
func (h *OgentHandler) ListUserLikedVideos(ctx context.Context, params ListUserLikedVideosParams) (ListUserLikedVideosRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryLikedVideos()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserLikedVideosOKApplicationJSON(NewUserLikedVideosLists(es)), nil
}

// ListUserViewedVideos handles GET /users/{id}/viewed-videos requests.
func (h *OgentHandler) ListUserViewedVideos(ctx context.Context, params ListUserViewedVideosParams) (ListUserViewedVideosRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryViewedVideos()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserViewedVideosOKApplicationJSON(NewUserViewedVideosLists(es)), nil
}

// ListUserModeratedVideos handles GET /users/{id}/moderated-videos requests.
func (h *OgentHandler) ListUserModeratedVideos(ctx context.Context, params ListUserModeratedVideosParams) (ListUserModeratedVideosRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryModeratedVideos()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListUserModeratedVideosOKApplicationJSON(NewUserModeratedVideosLists(es)), nil
}

// CreateVideo handles POST /videos requests.
func (h *OgentHandler) CreateVideo(ctx context.Context, req CreateVideoReq) (CreateVideoRes, error) {
	b := h.client.Video.Create()
	// Add all fields.
	b.SetUUID(req.UUID)
	b.SetTitle(req.Title)
	b.SetDescription(req.Description)
	b.SetVideotype(req.Videotype)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	b.AddStreamerIDs(req.Streamers...)
	b.AddModeraterIDs(req.Moderaters...)
	b.AddLikeIDs(req.Likes...)
	b.AddViewerIDs(req.Viewers...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Video.Query().Where(video.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewVideoCreate(e), nil
}

// ReadVideo handles GET /videos/{id} requests.
func (h *OgentHandler) ReadVideo(ctx context.Context, params ReadVideoParams) (ReadVideoRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewVideoRead(e), nil
}

// UpdateVideo handles PATCH /videos/{id} requests.
func (h *OgentHandler) UpdateVideo(ctx context.Context, req UpdateVideoReq, params UpdateVideoParams) (UpdateVideoRes, error) {
	b := h.client.Video.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UUID.Get(); ok {
		b.SetUUID(v)
	}
	if v, ok := req.Title.Get(); ok {
		b.SetTitle(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Videotype.Get(); ok {
		b.SetVideotype(v)
	}
	if v, ok := req.CreatedAt.Get(); ok {
		b.SetCreatedAt(v)
	}
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	b.ClearStreamers().AddStreamerIDs(req.Streamers...)
	b.ClearModeraters().AddModeraterIDs(req.Moderaters...)
	b.ClearLikes().AddLikeIDs(req.Likes...)
	b.ClearViewers().AddViewerIDs(req.Viewers...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Video.Query().Where(video.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewVideoUpdate(e), nil
}

// DeleteVideo handles DELETE /videos/{id} requests.
func (h *OgentHandler) DeleteVideo(ctx context.Context, params DeleteVideoParams) (DeleteVideoRes, error) {
	err := h.client.Video.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteVideoNoContent), nil

}

// ListVideo handles GET /videos requests.
func (h *OgentHandler) ListVideo(ctx context.Context, params ListVideoParams) (ListVideoRes, error) {
	q := h.client.Video.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListVideoOKApplicationJSON(NewVideoLists(es)), nil
}

// ReadVideoGroup handles GET /videos/{id}/group requests.
func (h *OgentHandler) ReadVideoGroup(ctx context.Context, params ReadVideoGroupParams) (ReadVideoGroupRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID)).QueryGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewVideoGroupRead(e), nil
}

// ListVideoStreamers handles GET /videos/{id}/streamers requests.
func (h *OgentHandler) ListVideoStreamers(ctx context.Context, params ListVideoStreamersParams) (ListVideoStreamersRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID)).QueryStreamers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListVideoStreamersOKApplicationJSON(NewVideoStreamersLists(es)), nil
}

// ListVideoModeraters handles GET /videos/{id}/moderaters requests.
func (h *OgentHandler) ListVideoModeraters(ctx context.Context, params ListVideoModeratersParams) (ListVideoModeratersRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID)).QueryModeraters()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListVideoModeratersOKApplicationJSON(NewVideoModeratersLists(es)), nil
}

// ListVideoLikes handles GET /videos/{id}/likes requests.
func (h *OgentHandler) ListVideoLikes(ctx context.Context, params ListVideoLikesParams) (ListVideoLikesRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID)).QueryLikes()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListVideoLikesOKApplicationJSON(NewVideoLikesLists(es)), nil
}

// ListVideoViewers handles GET /videos/{id}/viewers requests.
func (h *OgentHandler) ListVideoViewers(ctx context.Context, params ListVideoViewersParams) (ListVideoViewersRes, error) {
	q := h.client.Video.Query().Where(video.IDEQ(params.ID)).QueryViewers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return ListVideoViewersOKApplicationJSON(NewVideoViewersLists(es)), nil
}
